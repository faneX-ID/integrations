name: PR Assistant

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
  push:
    branches: [main, master]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: write
  issues: write

env:
  # Source of Truth: faneX-ID main repository (separate GitHub repository)
  # This workflow fetches version info from the main repository via HTTP
  MAIN_REPO: "faneX-ID/core"
  MAIN_BRANCH: "main"

jobs:
  # =================================================================================
  # JOB 1: PR Validation & Feedback
  # Validates integration manifests, code, and structure
  # =================================================================================
  pr-validation:
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install Dependencies
        run: |
          pip install jsonschema requests pyyaml

      # --- 0. Fetch Version Info from Main Repository (Source of Truth) ---
      # Note: This is a separate GitHub repository, so we fetch via HTTP
      # The versions.json is in the PUBLIC faneX-ID/faneX-ID repository, accessible to all repos
      - name: ðŸ“¥ Fetch Version Info from faneX-ID Main Repository
        id: versions
        run: |
          python << 'EOF'
          import json
          import requests
          import os

          # Always use the main repository (faneX-ID/core)
          # This works for both public and private dependent repositories
          main_repo = 'faneX-ID/core'  # Main repository
          main_branch = os.environ.get('MAIN_BRANCH', 'main')

          # Public URL - accessible to all repositories (public and private)
          versions_url = f"https://raw.githubusercontent.com/{main_repo}/{main_branch}/.github/versions.json"

          try:
              response = requests.get(versions_url, timeout=10)
              response.raise_for_status()
              versions = response.json()

              # Set output variables
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"schema_version={versions.get('manifest_schema_version', '2.0.0')}\n")
                  f.write(f"required_version={versions.get('required_manifest_version', '2.0.0')}\n")
                  f.write(f"schema_base_url={versions.get('schema_base_url', '')}\n")

              print(f"âœ… Fetched versions from public {main_repo} repository")
              print(f"   Schema Version: {versions.get('manifest_schema_version')}")
              print(f"   Required Version: {versions.get('required_manifest_version')}")
          except Exception as e:
              print(f"âš ï¸ Could not fetch versions from main repo: {e}")
              print("   Using fallback values")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write("schema_version=2.0.0\n")
                  f.write("required_version=2.0.0\n")
                  f.write("schema_base_url=\n")
          EOF

      # --- 1. Validate addons.json ---
      - name: ðŸ“‹ Validate addons.json
        run: |
          python << 'EOF'
          import json
          import sys
          from pathlib import Path

          addons_json = Path("addons.json")
          if not addons_json.exists():
              print("âŒ addons.json not found")
              sys.exit(1)

          with open(addons_json) as f:
              data = json.load(f)

          if "addons" not in data or not isinstance(data["addons"], list):
              print("âŒ addons.json must contain 'addons' array")
              sys.exit(1)

          print(f"âœ… addons.json valid ({len(data['addons'])} addons)")
          EOF

      # --- 2. Validate Integration Manifests ---
      - name: ðŸ“ Validate Integration Manifests
        env:
          SCHEMA_VERSION: ${{ steps.versions.outputs.schema_version }}
          REQUIRED_VERSION: ${{ steps.versions.outputs.required_version }}
          SCHEMA_BASE_URL: ${{ steps.versions.outputs.schema_base_url }}
        run: |
          python << 'EOF'
          import json
          import sys
          import os
          from pathlib import Path
          from jsonschema import validate, Draft7Validator

          SCHEMA_BASE_URL = os.environ.get('SCHEMA_BASE_URL', '')
          if SCHEMA_BASE_URL:
              SCHEMA_URL = f"{SCHEMA_BASE_URL}/integration-manifest.json"
          else:
              SCHEMA_URL = "https://raw.githubusercontent.com/faneX-ID/core/main/docs/specs/integrations-manifest/schemas/integration-manifest.json"

          REQUIRED_VERSION = os.environ.get('REQUIRED_VERSION', '2.0.0')

          try:
              import requests
              response = requests.get(SCHEMA_URL, timeout=10)
              response.raise_for_status()
              schema = response.json()
          except Exception as e:
              print(f"âš ï¸ Could not fetch schema from {SCHEMA_URL}, using local validation")
              schema = {}  # Fallback to basic validation

          validator = Draft7Validator(schema) if schema else None
          errors = []
          validated = 0

          print("Validating integration manifests...")

          for manifest_path in Path(".").rglob("*/manifest.json"):
              # Skip root-level files
              if manifest_path.parent == Path("."):
                  continue

              integration_dir = manifest_path.parent
              integration_name = integration_dir.name

              try:
                  with open(manifest_path) as f:
                      manifest = json.load(f)

                  # Basic validation
                  required_fields = ["schema_version", "domain", "name", "version", "description", "implementations"]
                  for field in required_fields:
                      if field not in manifest:
                          errors.append(f"{integration_name}: missing required field '{field}'")
                          continue

                  # Schema version check (from main repo)
                  schema_version = manifest.get("schema_version", "0.0.0")
                  required_version = os.environ.get('REQUIRED_VERSION', '2.0.0')
                  if schema_version != required_version:
                      errors.append(f"{integration_name}: schema_version must be {required_version}, got {schema_version}")

                  # Check implementations exist
                  implementations = manifest.get("implementations", {})
                  for lang, filename in implementations.items():
                      impl_path = integration_dir / filename
                      if not impl_path.exists():
                          errors.append(f"{integration_name}: implementation file '{filename}' not found")

                  # Check README exists
                  readme_path = integration_dir / "README.md"
                  if not readme_path.exists():
                      errors.append(f"{integration_name}: README.md not found")

                  # Schema validation if available
                  if validator:
                      validation_errors = list(validator.iter_errors(manifest))
                      if validation_errors:
                          for error in validation_errors:
                              errors.append(f"{integration_name}: {error.message}")

                  if not any(e.startswith(integration_name) for e in errors):
                      validated += 1
                      print(f"âœ… {integration_name} valid")

              except json.JSONDecodeError as e:
                  errors.append(f"{integration_name}: Invalid JSON - {e}")
              except Exception as e:
                  errors.append(f"{integration_name}: {e}")

          if errors:
              print("\nâŒ Errors found:")
              for e in errors:
                  print(f"  - {e}")
              sys.exit(1)
          else:
              print(f"\nâœ… All {validated} integration(s) valid.")
          EOF

      # --- 3. Validate Quality Scores (if present) ---
      - name: ðŸ“Š Validate Quality Scores
        continue-on-error: true
        run: |
          python << 'EOF'
          import json
          import jsonschema
          from pathlib import Path
          import requests

          # Fetch schema from main repo
          schema_url = "https://raw.githubusercontent.com/faneX-ID/core/main/docs/specs/integrations-manifest/schemas/quality-score.json"
          try:
              response = requests.get(schema_url, timeout=10)
              response.raise_for_status()
              schema = json.loads(response.text)
          except Exception as e:
              print(f"âš ï¸  Could not fetch quality score schema: {e}")
              exit(0)

          errors = []
          warnings = []

          # Check all integrations
          for manifest_path in Path(".").glob("*/manifest.json"):
              integration_name = manifest_path.parent.name
              quality_file = manifest_path.parent / "quality.json"

              if quality_file.exists():
                  try:
                      with open(quality_file) as f:
                          quality_data = json.load(f)

                      # Validate against schema
                      jsonschema.validate(instance=quality_data, schema=schema)

                      # Check that quality.json is not manually edited (should have calculated_by)
                      if quality_data.get("calculated_by") != "quality-calculator":
                          warnings.append(f"{integration_name}: quality.json may have been manually edited")

                      print(f"âœ… {integration_name}: quality.json is valid ({quality_data.get('overall_score', 0):.1f}/100)")
                  except jsonschema.ValidationError as e:
                      errors.append(f"{integration_name}: quality.json validation failed - {e.message}")
                      print(f"âŒ {integration_name}: {e.message}")
                  except Exception as e:
                      errors.append(f"{integration_name}: Error reading quality.json - {str(e)}")
                      print(f"âŒ {integration_name}: {str(e)}")
              else:
                  # Quality file missing is not an error, just a note
                  pass

          if warnings:
              print("\nâš ï¸  Warnings:")
              for warning in warnings:
                  print(f"   â€¢ {warning}")

          if errors:
              print("\nâŒ Quality Score Validation Errors:")
              for error in errors:
                  print(f"   â€¢ {error}")
              exit(1)
          else:
              print("\nâœ… All quality scores are valid")
          EOF

      # --- 4. Check Code Quality ---
      - name: ðŸ” Check Python Code Quality
        run: |
          python << 'EOF'
          import ast
          import sys
          from pathlib import Path

          errors = []
          checked = 0

          for py_file in Path(".").rglob("integration.py"):
              integration_name = py_file.parent.name
              try:
                  with open(py_file) as f:
                      code = f.read()

                  # Basic syntax check
                  try:
                      ast.parse(code)
                      checked += 1
                      print(f"âœ… {integration_name}/integration.py syntax valid")
                  except SyntaxError as e:
                      errors.append(f"{integration_name}: Syntax error - {e}")

              except Exception as e:
                  errors.append(f"{integration_name}: Error reading file - {e}")

          if errors:
              print("\nâŒ Code quality issues:")
              for e in errors:
                  print(f"  - {e}")
              sys.exit(1)
          else:
              print(f"\nâœ… All {checked} Python file(s) valid.")
          EOF

      # --- 4. Feedback Comment ---
      - name: Feedback Comment
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const outcome = '${{ job.status }}';
            if (outcome === 'failure') {
               github.rest.issues.createComment({
                 issue_number: context.issue.number,
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 body: "âŒ **PR Validation Failed**\n\nPlease check:\n- Integration manifests are valid (schema_version 2.0.0)\n- All required files exist (manifest.json, integration.py, README.md)\n- Python code syntax is correct\n- addons.json is valid"
               });
            } else if (outcome === 'success') {
               github.rest.issues.createComment({
                 issue_number: context.issue.number,
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 body: "âœ… **PR Validation Passed**\n\nAll integration checks passed successfully!"
               });
            }

  # =================================================================================
  # JOB 2: Auto-Fix (if applicable)
  # =================================================================================
  auto-fix:
    needs: pr-validation
    if: failure() && github.event_name == 'pull_request' && github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.head_ref }}
      - name: Auto-fix suggestions
        run: |
          echo "Auto-fix not available for integration repositories"
          echo "Please fix issues manually based on validation feedback"

  # =================================================================================
  # JOB 3: Thank Contributor
  # =================================================================================
  thank-you:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v6
        with:
          script: |
            const author = context.payload.pull_request.user.login;
            const admins = ['FaserF', 'fabia', 'github-actions[bot]'];
            if (admins.includes(author)) return;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸŽ‰ **Thank you @${author}!**\n\nYour contribution to the **faneX-ID Integrations** repository is valuable! ðŸš€`
            });
